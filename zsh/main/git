# -*- mode: sh -*-

################################################################################
# Git Log
glog ()
{
    git-log --pretty=format:'%Cgreen%h%Creset %Cred%ci%Creset %Cblue%ae%Creset %s' $@
}

################################################################################
# Resolve conflicts by keeping the local changes and throwing away the
# remote changes
git_resolve_with_local ()
{
  if [ $# -eq 0 ]; then
    FILES=`git ls-files -u | awk '{if ($3==1) print $4;}'`
    test -z "$FILES" && exit
  else
    FILES=$*
  fi

  PREFIX=`git rev-parse --show-prefix`
  
  # need the echo below because the files are someone all glued
  # together in a single string
  for f in `echo $FILES`; do
    echo "--> Tossing remote changes for $f"
    git cat-file blob ":2:${PREFIX}${f}" >| "$f" 2> /dev/null
    touch "$f"
    git add -- "$f"
  done
  
  echo "now run git-commit"
}

################################################################################
# Test to see if a repository has any uncommitted changes
git_repo_has_changes ()
{
  if ! git-status|grep -q -F '(working directory clean)'; then
    return 0
  else
    return 1
  fi
}

################################################################################
# Track a remote branch
git_track ()
{
  if [ $# -ne 1 ]; then
    echo "$0: missing branch name"
    return 1
  fi

  branch=$1
  git-branch --track $branch origin/$branch || return 1
}

################################################################################
# Create a new branch, and push it to the origin server
git_make_branch ()
{
  if [ $# -ne 1 ]; then
    echo "$0: missing branch name"
    return 1
  fi

  branch=$1

  git-checkout -b $branch || return 1
  git-push origin $branch || return 1
  git-checkout master     || return 1
  git-branch -d $branch   || return 1
  git-pull                || return 1
  git_track $branch       || return 1
  git-checkout $branch    || return 1
}
