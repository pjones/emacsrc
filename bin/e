#!/usr/bin/env ruby

################################################################################
require('optparse')

################################################################################
class RemoteEmacs

  ##############################################################################
  REMOTE_SERVER_FILE = File.expand_path('~/develop/emacs.server')

  ##############################################################################
  DEFAULT_OPTIONS = {
    'verbose' => false,
    'server'  => 'server',
    'version' => false,
    'tty'     => false,
    'frame'   => false,
    'eval'    => false,
    'wait'    => false,
  }

  ##############################################################################
  OptionProxy = Struct.new(*DEFAULT_OPTIONS.keys.sort.map {|k| k.to_sym})

  ##############################################################################
  def initialize
    @options = OptionProxy.new(*DEFAULT_OPTIONS.keys.sort.map {|k| DEFAULT_OPTIONS[k]})

    OptionParser.new do |p|
      p.on('-h', '--help', 'This message.') {$stdout.puts(p); exit}
      p.on('-V', '--version', 'Show Emacs version information') {|v| @options.version = v}
      p.on('--verbose', 'Enable verbose messages') {|v| @options.verbose = v}
      p.on('-t', '--tty', 'Open a new frame on the current terminal') {|t| @options.tty = t}
      p.on('-c', '--create-frame', 'Create a new Emacs frame') {|f| @options.frame = f}
      p.on('-e', '--eval', 'Eval the file argument as lisp') {|e| @options.eval = e}
      p.on('-n', '--no-wait', 'Don\'t wait for Emacs [default]') {@options.wait = false}
      p.on('-w', '--wait', 'Wait for Emacs to finish') {@options.wait = true}
      p.on('-s', '--server=NAME', 'Set the server name to use') {|s| @options.server = s}
    end.parse!(ARGV)

    @emacsclient = ['emacsclient']
    @socket_file = File.expand_path("~/.emacs.d/server/#{@options.server}")
  end

  ##############################################################################
  def run
    @emacsclient << '--quiet'        if !@options.verbose
    @emacsclient << '--version'      if @options.version
    @emacsclient << '--tty'          if @options.tty
    @emacsclient << '--create-frame' if @options.frame
    @emacsclient << '--eval'         if @options.eval

    if !@options.wait    and
       !@options.tty     and
       !@options.eval    and
       !@options.version
    then
      @emacsclient << '--no-wait'
    end

    if !File.exist?(@socket_file)
      prepare_for_remote_send
    else
      @emacsclient << "--server-file=#{@socket_file}"
    end

    @emacsclient.concat(ARGV)
    $stdout.puts(@emacsclient.join(' ')) if @options.verbose
    exec(*@emacsclient) || raise('emacsclient failed')
  end

  ##############################################################################
  private

  ##############################################################################
  def prepare_for_remote_send
    details = File.read(REMOTE_SERVER_FILE).
      sub('0.0.0.0', ENV['SSH_CLIENT'].split.first)
    File.open(REMOTE_SERVER_FILE, 'w') {|f| f.write(details)}

    @emacsclient << "--server-file=#{REMOTE_SERVER_FILE}"
    return if @options.eval

    host  = `hostname`.chomp
    mount = File.expand_path('~/develop')

    ARGV.map! do |arg|
      file = File.expand_path(arg)
      file.sub(mount, "/home/pjones/develop/hosts/#{host}")
    end
  end
end

################################################################################
begin
  RemoteEmacs.new.run
rescue RuntimeError => e
  $stderr.puts(File.basename($0) + ": ERROR: #{e}")
  exit(1)
end
