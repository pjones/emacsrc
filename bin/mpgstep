#!/usr/bin/env ruby

################################################################################
require('curses')
require('ostruct')
require('yaml')

################################################################################
class Stepper
  
  ##############################################################################
  DISPATCH_TABLE = {
    ?b => :jump_back,
    ?c => :copy_last_mark,
    ?d => :delete_last_mark,
    ?m => :mark,
    ?p => :pause,
    ?q => :quit,
    ?r => :play_back,
    ?w => :write_marks,
    ?- => :up_a_mark,
    ?= => :down_a_mark,
    ?+ => :down_a_mark,
  }
  
  ##############################################################################
  SMALL_SEEK = "2s"
  
  ##############################################################################
  def initialize
    @mp3_file  = ARGV[0]
    @save_file = ARGV[1]
    
    if @mp3_file.nil? or !File.exist?(@mp3_file)
      raise("no such mp3 file: #{@mp3_file.inspect}")
    end
    
    @playing = false
    @running = true
    @title = ''
    @last_frame_line  = nil
    @current_frame = nil
    @current_sec = nil
    @current_split_code = nil
    @remain_sec = nil

    @last_status_message = ''
    @marks = [OpenStruct.new(:frame => 0, :sec => '00:00.00', :remain => '00:00.00', :split => '0.0.0')]

    if @save_file and File.exist?(@save_file)
      @marks.clear

      YAML.load_file(@save_file).each do |mark|
        @marks << OpenStruct.new(mark)
      end
    end
    
    @current_mark_index = @marks.size - 1

    Curses.init_screen
    Curses.noecho
  end
  
  ##############################################################################
  def run
    @mpg123 = open("|mpg123 -R 2> /dev/null", 'w+')
    @mpg123.write("lp #{@mp3_file}\n")
    @mpg123.write("scan\n")
    switched_mark
    process_mpg123_input
    playing_status
    event_loop while @running
  ensure
    @mpg123.close
    Curses.close_screen
  end

  ##############################################################################
  private
  
  ##############################################################################
  def event_loop
    process_mpg123_input
    
    if char = Curses::getch
      send(DISPATCH_TABLE[char]) if DISPATCH_TABLE.has_key?(char)
    end
  end

  ##############################################################################
  def process_mpg123_input
    while select([@mpg123], nil, nil, 0.1)
      line = @mpg123.gets
      code = line[0, 2]
      
      case code
      when "@E" then raise(line)
      when "@F" then @last_frame_line = line
      when "@I" then look_for_title(line)
      end
    end
  end
  
  ##############################################################################
  def status (main, options={})
    ops = {
      :alt => nil,
    }.merge(options)

    Curses.setpos(0, 0)
    Curses.addstr("%-#{Curses.cols - 1}s" % @title)
    
    if ops[:alt]
      y = Curses.cols - ops[:alt].size - 1
      Curses.setpos(0, y)
      Curses.addstr(ops[:alt])
    end

    @last_status_message = main if main
    Curses.setpos(Curses.lines - 1, 0)
    Curses.addstr("%-#{Curses.cols - 1}s" % @last_status_message)

    if @current_sec and @remain_sec
      position = "[#{@current_sec} / #{@remain_sec}]"
      Curses.setpos(Curses.lines - 1, Curses.cols - position.size - 1)
      Curses.addstr(position)
    end

    display_mark_list
    Curses.setpos(0, 0)
    Curses.refresh
  end
  
  ##############################################################################
  def display_mark_list
    lines = Curses.lines - 4
    cols = (Curses.cols / 15).floor
    total = lines * cols
    index = 0

    last_x = Curses.lines - 3
    x = 2
    y = 0
    
    if @marks.size > total
      index = @marks.size - total
    end
    
    while index < @marks.size
      current = (index == @current_mark_index ? '*' : ' ')

      Curses.setpos(x, y)
      Curses.addstr("%s %02d: %s" % [current, index, @marks[index].sec])
      
      if x == last_x
        x = 2
        y += 15
      else
        x += 1
      end

      index += 1
    end
  end
  
  ##############################################################################
  def switched_mark
    mark = @marks[@current_mark_index]
    @mpg123.write("j #{mark.frame}\n")
    @current_sec = mark.sec
    @remain_sec = mark.remain
    status(nil)
  end
  
  ##############################################################################
  def playing_status
    parse_last_frame if @last_frame_line
    status(@playing ? 'Playing' : 'Paused')
  end

  ##############################################################################
  def parse_last_frame
    parts = @last_frame_line.split(' ')
    @current_frame = parts[1].to_i
    @current_sec = parse_seconds(parts[3].to_f)
    @remain_sec = parse_seconds(parts[4].to_f)
    
    min, sec = minutes_and_fractional_seconds(parts[3].to_f)
    @current_split_code = "%d.%.2f" % [min, sec]
  end
  
  ##############################################################################
  def parse_seconds (seconds)
    minutes, seconds = minutes_and_fractional_seconds(seconds)
    "%02d:%02d.%02d" % [minutes, seconds, (seconds * 100.0) % 100]
  end
  
  ##############################################################################
  def minutes_and_fractional_seconds (seconds)
    minutes = (seconds / 60.0).floor
    seconds -= (minutes.to_f * 60.0)
    [minutes, seconds]
  end
  
  ##############################################################################
  def look_for_title (line)
    if m = line.match(/ID3v2.title:(.*)$/)
      @title = m[1]
    end
  end

  ##############################################################################
  def pause
    @mpg123.write("p\n")
    @playing = !@playing
    process_mpg123_input
    playing_status
  end
  
  ##############################################################################
  def mark
    if !@playing and 
       @current_sec and 
       @current_sec != @marks[-1].sec and
       @current_mark_index == (@marks.size - 1)
    then
      @marks << OpenStruct.new(:frame => @current_frame, 
                               :sec => @current_sec, 
                               :remain => @remain_sec,
                               :split => @current_split_code)
      write_marks
      @current_mark_index = @marks.size - 1
      status(nil, :alt => 'Marked')
    end
  end
  
  ##############################################################################
  def play_back
    return if @playing or @current_mark_index.zero?
    
    start_pos = @marks[@current_mark_index - 1]
    end_pos   = @marks[@current_mark_index]
    status("Replay")

    @playing = true
    @mpg123.write("j #{start_pos.frame}\np\n")
    
    while true
      if (line = @mpg123.gets)[0, 2] == '@F'
        parts = line.split(' ')
        break if parts[1].to_i >= end_pos.frame
      end
    end
    
    pause
  end
  
  ##############################################################################
  def copy_last_mark
    mark = @marks.last

    open("|pbcopy", 'w') do |pbcopy|
      pbcopy.write(mark.sec)
    end
    
    status(nil, :alt => 'Copy')
  end
  
  ##############################################################################
  def delete_last_mark
    if @marks.size > 1
      @marks.pop
      write_marks
      Curses.clear
      status(nil, :alt => 'Deleted')
    end
  end
  
  ##############################################################################
  def jump_back
    cmd = "j -#{SMALL_SEEK}\n"
    cmd = "p\n#{cmd}p\n" if !@playing
    @mpg123.write(cmd)
    process_mpg123_input
    status(nil, :alt => 'Jump')
  end
  
  ##############################################################################
  def quit
    @running = false
  end
  
  ##############################################################################
  def write_marks
    File.open(@save_file, 'w') do |file|
      file.write(@marks.map {|m| m.send(:table)}.to_yaml)
    end
  end
  
  ##############################################################################
  def up_a_mark
    if @current_mark_index != 0
      @current_mark_index -= 1
      switched_mark
    end
  end
  
  ##############################################################################
  def down_a_mark
    if @current_mark_index != (@marks.size - 1)
      @current_mark_index += 1
      switched_mark
    end
  end
end

################################################################################
begin
  Stepper.new.run
rescue RuntimeError => e
  $stderr.puts(File.basename($0) + ": ERROR: #{e}")
  exit(1)
end
